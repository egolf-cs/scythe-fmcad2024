'''This module implements the procedure for inferring constraints on the
sygus solver from the counterexamples generated by the TLA+ model checker.
'''
from pprint import pprint
import itertools
from .tlc_interface.violations import (
    violation_traversal, 
    pprint_violation, 
    get_cycle,
    get_deadlocked_state, 
    DEADLOCK, 
    TLCTransition,
    # parse_value,
)

try:
    from ..operator_table import OPERATOR_TABLE
except ImportError:
    from operator_table import OPERATOR_TABLE

def powerset(s):
    return frozenset(
        frozenset(x) for x in itertools.chain.from_iterable(
            itertools.combinations(s, r) for r in range(len(s)+1)))

def act_transitions(violation, action):
    relevant = [action, "Stuttering"]
    return [t for t in violation_traversal(violation) if t.action in relevant]

def parse_state(state, param_map, depends, constant_map):
    '''Retrieve the relevant values from the state and the param_map,
    given that depends are the variables that an uninterpreted function
    depends on.

    The return value is a tuple (ufn_args, mapping) where
    - ufn_args is a list of the values of the variables in depends
    - mapping is a dictionary that maps each variable in depends to its value
    I.e., ufn_args is an ordered version of mapping, essentially.
    '''
    ufn_args = []
    mapping = {}
    sorts = {}
    for var, sort in depends:
        if var in param_map:
            tmp = param_map[var]
        elif var in constant_map:
            tmp = constant_map[var]
        elif var not in state:
            raise ValueError(
                f"State variable {var} not found in state {state}."
                f" param_vars={param_map}")
        else:
            tmp = state[var]
        mapping[var] = tmp
        ufn_args.append(var)
        sorts[var] = sort
    return ufn_args, mapping, sorts

def constraints_from_transition(
        violation, transition, interpretation, param_map, ufn, depends, 
        constant_map, pre_constraint=None):
    '''This function assumes
        - transition is a transition from a violating trace
        - the action of transition involves the uninterpreted function ufn
            in the sketch
        - ufn depends on the state variables in arg depends and the parameters
            of the action
        - interpretation is a problematic interpretation of ufn
    Then the job of this function is to compute a constraint on ufn that will
    prevent the sygus solver from using interpretation as a solution.
    
    If pre_constraint is true, then None is returned unless interpretation
    evaluates to
    '''

    assert(isinstance(constant_map, dict))

    src = transition.src
    ufn_args, mapping, sorts = parse_state(
        violation.states[src], param_map, depends, constant_map)

    is_constant = lambda x: x in constant_map
    inputs = _parse_valuation(mapping, sorts, is_constant)
    output = eval_expression(interpretation, inputs)

    # return (ufn, ufn_args, interpretation, mapping, sorts)
    return (ufn, inputs, output)

def mk_path_terms(violation, interpretation, action, ufn, depends, param_maps, constant_map):
    '''The param_maps argument is only necessary when the action is stuttering.
    In the future we may be able to remove this functionaliy, but it requires
    TLC to tell us which action caused the stuttering.
    '''
    ts = act_transitions(violation, action)
    res = []
    for t in ts:
        if t.action != "Stuttering":
            param_map = dict(t.params)
            param_maps = [param_map]
        elif t.action == "Stuttering":
            # raise ValueError("Stuttering no longer supported in this way.")
            pass
        else:
            raise ValueError(
                f"Unexpected action {t.action}. Should be Stuttering or"
                f" {action}.")
        # print("violation type", violation.sort)
        # print("param_maps", param_maps)
        for pm in param_maps:
            # Need to only add these constraints if it would strengthen the
            # pre-condition or change the post-condition of t.action.
            tmp = constraints_from_transition(
                violation, t, interpretation, pm, ufn, depends, constant_map)
            res.append(tmp)
    return res

def mk_cycle_terms(
        violation, interpretation, ufn, depends, param_maps, constant_map):
    cycle = get_cycle(violation)
    # pprint_violation(violation)
    # pprint(violation.raw)
    if cycle is None:
        return []
    ts = list(violation_traversal(cycle))
    res = []
    for t in ts:
        for param_map in param_maps:
            # Need to only add these constraints if t.action is enabled
            tmp = constraints_from_transition(
                violation, t, interpretation, param_map, ufn, depends, 
                constant_map)
            res.append(tmp)
    return res

def mk_deadlock_terms(violation, interpretation, ufn, depends, param_maps, constant_map):
    # The idea is to create a dummy self-loop on the final state of the deadlock
    #   violation and then use the same code as for cycle violations.

    deadlocked_state = get_deadlocked_state(violation)
    
    t = TLCTransition("Dummy", dict(), deadlocked_state, deadlocked_state)
    res = []
    for param_map in param_maps:
        # Need to only add these constraints if t.action is enabled
        tmp = constraints_from_transition(
            violation, t, interpretation, param_map, ufn, depends, constant_map)
        res.append(tmp)
    return res

def make_constraint(
        violation, interpretation, action, is_fair, is_guard, ufn, 
        depends, param_maps, constant_map):
    # path terms identify constraints such that atleast one of them
    # must hold in order to
    # - break the path to a deadlocked state
    # - break the path to an unsafe state
    # - break the path to a bad cycle or break the cycle for liveness violations
    res = mk_path_terms(
        violation, interpretation, action, ufn, depends, param_maps, 
        constant_map)
    if violation.sort == DEADLOCK:
        # the deadlock terms identify constraints such that at least one of 
        # them must hold in order
        # to leave the dealocked state, i.e., make it non-deadlocked.
        # Unlike the cycle terms, the deadlock terms do not have to pick out
        # fair actions. This is because any action can be used to escape
        # a deadlock. But, as for the cycle terms, the deadlock terms
        # should not be added if the hole identified by args is an update.
        # Again, this is because changing an update hole does not allow
        # to escape a deadlock (since the action is not enabled, regardless
        # of the contents of the update).
        dl_terms = []
        if is_guard:
            dl_terms = mk_deadlock_terms(
                violation, interpretation, ufn, depends, param_maps, 
                constant_map)
        res += dl_terms
    else:
        # the cycle terms identify constraints such that at least one of them 
        # must hold in order
        # to exit a bad cycle in the case of a liveness violation.
        # If the hole identified by args is an update, then we should not
        # add any cycle terms. Also, if the action is not fair, then we
        # should not add cycle terms. This is because fixing an update
        # hole does not allow to escape a bad cycle, and only fair actions
        # can be used to escape a bad cycle.
        cycle_terms = []
        if is_fair and is_guard:
            cycle_terms = mk_cycle_terms(
                violation, interpretation, ufn, depends, param_maps, 
                constant_map)
        res += cycle_terms
    return res

def make_constraints(violation, ufn_args, constant_map):
    res = []
    for ufn, args in ufn_args.items():
        interpretation = args["interpretation"]
        action = args["action"]
        is_fair = args["is_fair"]
        is_guard = args["is_guard"]
        depends = args["depends"]
        param_maps = args["param_maps"]
        res += make_constraint(
            violation, interpretation, action, is_fair, is_guard, ufn, depends, 
            param_maps, constant_map)
    if res == []:
        pprint(ufn_args)
        pprint_violation(violation)
        raise ValueError(
            "No constraints added. This may indicate that weak fairness is not" 
            " handled correctly. E.g. for escaping liveness violations."
            " It may also be an issue with how Stuttering is handled."
            " Or, it may be that the specification really is unrealizable: a"
            " violation was generated that does not depend on any actinos that"
            " have holes")
    # REMOVE_ME
    # pprint(res)
    # return ["or"] + res
    return res

def constraints_size(constraints):
    if isinstance(constraints, list):
        return sum([constraints_size(c) for c in constraints])
    else:
        return 1


###########

def _res_union_sort(sort):
    tail = sort[1:]
    if len(tail) != 2:
        raise ValueError(f"Expected union sort of length 2, got {sort}")
    left, right = tail
    if isinstance(left, tuple) and left[0] == "Tuple":
        if not (isinstance(right, tuple) and right[0] == "Tuple"):
            raise ValueError(f"Unsupported union sort: {sort}")
        left_tail = left[1:]
        right_tail = right[1:]
        if len(left_tail) != len(right_tail):
            raise ValueError(f"Unsupported union sort: {sort}")
        zs = zip(left_tail, right_tail)
        zs = [("Union", x, y) for x, y in zs]
        res = ("Tuple",) + tuple(_res_union_sort(z) for z in zs)
        return res
    else:
        def good_sort(x):
            if isinstance(x, tuple) and x[0] == "Dom":
                return True
            elif x == "Int":
                return True
            else:
                return False
        if good_sort(left) and good_sort(right):
            return left
        else:
            raise ValueError(f"Unsupported union sort: {sort}")

def _parse_value_set(val, sort, is_constant):
    if sort == ("Set", "Int"):
        if is_constant(val):
            assert(isinstance(val, str))
            return val
        elif val.startswith("{") and val.endswith("}"):
            args = val[1:-1].split(",")
            if args == [""]:
                return set()
            res = set()
            for v in args:
                res.add(_parse_value(v, sort[1], is_constant))
            return res
        else:
            raise ValueError(f"Do not know how to parse {sort}: {val}")
    elif (sort[0] == "Set"
          and isinstance(sort[1], tuple)
          and sort[1][0] == "Dom"):
        if is_constant(val):
            assert(isinstance(val, str))
            return val
        elif val.startswith("{") and val.endswith("}"):
            args = val[1:-1].split(",")
            if args == [""]:
                return set()
            res = set()
            for v in args:
                res.add(_parse_value(v, sort[1], is_constant))
            return res
    elif (sort[0] == "Set"
          and isinstance(sort[1], tuple)
          and sort[1][0] == "Union"):
        resolved_sort = _res_union_sort(sort[1])
        x = _parse_value_set(val, ("Set", resolved_sort), is_constant)
        # if val == "event_queue":
        #     print("event_queue")
        #     print(x)
        return x
    # elif sort == ("Set", ("Tuple", "Int", "Int")):
    elif (sort[0] == "Set" 
          and isinstance(sort[1], tuple)
          and sort[1][0] == "Tuple" 
          and all(
              (x == "Int" 
                or (isinstance(x, tuple) and x[0] == "Dom")) 
               for x in sort[1][1:])):
        if is_constant(val):
            assert(isinstance(val, str))
            return val
        elif val.startswith("{") and val.endswith("}"):
            args = val[1:-1].split(">>,<<")
            args = [x.replace("<", "").replace(">", "") for x in args]
            if args == [""]:
                return set()
            res = set()
            for v in args:
                ts = v.split(",")
                ts = [_parse_value(x, "Int", is_constant) for x in ts]
                res.add(tuple(ts))
            return res
        else:
            raise ValueError(f"Do not know how to parse {sort}: {val}")
    else:
        raise NotImplementedError(f"Unimplemented sort: {sort}")

def _parse_value(val, sort, is_constant):
    if not isinstance(val, str):
        raise ValueError(f"Expected string, got {val}")
    val = val.strip()
    if sort == "Int":
        # print("Int Val", val)
        if is_constant(val):
            assert(isinstance(val, str))
            return val
        elif val.isnumeric():
            return int(val)
        else:
            raise ValueError(
                f"Do not know how to parse Int: {val}."
                " Make sure constants are declared.")
    elif sort == "Bool":
        if is_constant(val):
            assert(isinstance(val, str))
            return val
        elif val == "TRUE":
            return True
        elif val == "FALSE":
            return False
        else:
            raise ValueError(f"Do not know how to parse Bool: {val}")
    elif sort[0] == "Dom":
        if is_constant(val):
            assert(isinstance(val, str))
            return val
        else:
            raise ValueError(
                f"Do not know how to parse Int: {val}."
                " Make sure constants are declared.")
    elif sort[0] == "Set":
        return _parse_value_set(val, sort, is_constant)
    elif sort[0] == "Seq":
        # print("Seq Val", val)
        if is_constant(val):
            assert(isinstance(val, str))
            return val
        if val == "<<>>":
            return tuple()
        t = ("Tuple",) + tuple(sort[1] for _ in val)
        # print("Deferring to Tuple...")
        res = _parse_value(val, t, is_constant)
        # print("Done.")
        return res
    elif sort[0] == "Tuple":
        if is_constant(val):
            assert(isinstance(val, str))
            return val
        elif val.startswith("<<") and val.endswith(">>"):
            args = val[2:-2].split(",")
            res = tuple(_parse_value(v, sort[i+1], is_constant) for i, v in enumerate(args))
            return res
        else:
            raise ValueError(f"Do not know how to parse {sort}: {val}")
    elif sort[0] == "Array":
        # print("sort", sort)
        if (
                isinstance(sort[-1], tuple) 
                and len(sort[-1]) > 0 
                and sort[-1][0] == "Array"):
            raise NotImplementedError(
                "Multidimensional arrays not supported. Map tuples to values.")
        if is_constant(val):
            assert(isinstance(val, str))
            return val
        elif val.startswith("(") and val.endswith(")"):
            kvs = val[1:-1].split("@@")
            kvs = [tuple(x.split(":>")) for x in kvs]
            res = dict()
            for k, v in kvs:
                parsed_k = _parse_value(k, sort[1], is_constant)
                parsed_v = _parse_value(v, sort[2], is_constant)
                res[parsed_k] = parsed_v
            return res
        else:
            raise ValueError(f"Do not know how to parse {sort}: {val}")
    else:  
        raise NotImplementedError(f"Unimplemented sort: {sort}")

def _parse_valuation(valuation, sorts, is_constant):
    # print("# _parse_valuation")
    # pprint(valuation)
    new_valuation = {}
    for v, val in valuation.items():
        if v not in sorts:
            raise ValueError(f"Valuation {v} not in sorts.")
        sort = sorts[v]
        if isinstance(val, str):
            parsed_val = _parse_value(val, sort, is_constant)
        else:
            parsed_val = eval_expression(val, None)
        new_valuation[v] = parsed_val
    return new_valuation

def eval_operator_expression(ophead, opargs):
    if ophead not in OPERATOR_TABLE:
        raise ValueError(f"Operator {ophead} not in OPERATOR_TABLE")
    evalfn, nargs = OPERATOR_TABLE[ophead]
    if len(opargs) != nargs:
        raise ValueError(
            f"Operator {ophead} expected {nargs} arguments, got {len(opargs)}")
    return evalfn(*opargs)

def eval_expression(expression, valuation):
    # print(expression)
    # Passing valuation=None allows for the evaluation of expressions
    # that do not depend on any valuation, e.g., in _parse_valuation.
    if valuation is None and isinstance(expression, str):
        return expression
    if isinstance(expression, str) and expression in valuation:
        # if expression == "event_queue":
            # print("event_queue")
            # print(valuation)
        return valuation[expression]
    elif isinstance(expression, list):
        if len(expression) == 0:
            raise ValueError("Empty expression")
        head = expression[0]
        tail = expression[1:]
        # print(expression)
        # print("head", head)
        if head == "set.union":
            # print("union", expression)
            if len(tail) != 2:
                # print(expression)
                raise ValueError("set.union takes two arguments")
            return (
                eval_expression(tail[0], valuation) 
                | eval_expression(tail[1], valuation))
        elif head == "set.singleton":
            # print("singleton", expression)
            if len(tail) != 1:
                raise ValueError("set.singleton takes one argument")
            return {eval_expression(tail[0], valuation)}
        elif head == "set.minus":
            if len(tail) != 2:
                raise ValueError("set.minus takes two arguments")
            return (
                eval_expression(tail[0], valuation) 
                - eval_expression(tail[1], valuation))
        elif head == "set.intersect":
            if len(tail) != 2:
                raise ValueError("set.intersect takes two arguments")
            left = eval_expression(tail[0], valuation)
            right = eval_expression(tail[1], valuation)
            return left & right
        elif head == "set.member":
            if len(tail) != 2:
                raise ValueError("set.member takes two arguments, got:", tail)
            left = eval_expression(tail[0], valuation)
            right = eval_expression(tail[1], valuation)
            return left in right
        elif head == "set.subset":
            if len(tail) != 2:
                raise ValueError("set.subset takes two arguments")
            return (
                eval_expression(tail[0], valuation) 
                <= eval_expression(tail[1], valuation))
        elif head == "cardinality":
            if len(tail) != 1:
                raise ValueError("cardinality takes one argument")
            return len(eval_expression(tail[0], valuation))
        elif head == ">":
            if len(tail) != 2:
                raise ValueError("> takes two arguments")
            return (
                eval_expression(tail[0], valuation) 
                > eval_expression(tail[1], valuation))
        elif head == "<":
            if len(tail) != 2:
                raise ValueError("< takes two arguments")
            return (
                eval_expression(tail[0], valuation) 
                < eval_expression(tail[1], valuation))
        elif head == ">=":
            if len(tail) != 2:
                raise ValueError(">= takes two arguments")
            left = eval_expression(tail[0], valuation)
            right = eval_expression(tail[1], valuation)
            return left >= right
        elif head == "<=":
            if len(tail) != 2:
                raise ValueError("<= takes two arguments")
            left = eval_expression(tail[0], valuation)
            right = eval_expression(tail[1], valuation)
            return left <= right
        elif head == "=":
            if len(tail) != 2:
                raise ValueError("= takes two arguments")
            left = eval_expression(tail[0], valuation) 
            right = eval_expression(tail[1], valuation)
            return (left == right)
        elif head == "seq.len":
            if len(tail) != 1:
                raise ValueError("seq.len takes one argument")
            # print(tail[0])
            return len(eval_expression(tail[0], valuation))
        elif head == "seq.at":
            if len(tail) != 2:
                raise ValueError("seq.at takes two arguments")
            seq = eval_expression(tail[0], valuation)
            idx = eval_expression(tail[1], valuation)
            if not isinstance(idx, int):
                raise ValueError("seq.at index must be an integer. Got ", idx)
            if idx < 1 or idx > len(seq):
                raise ValueError(
                    f"Index {idx} out of bounds for sequence {seq}."
                    " Note: TLA+ is 1-indexed.")
            return seq[idx-1]
        elif head == "seq.domain":
            if len(tail) != 1:
                raise ValueError("seq.domain takes one argument")
            seq = eval_expression(tail[0], valuation)
            return frozenset(range(1, len(seq)+1))
        elif head == "select":
            if len(tail) != 2:
                raise ValueError("select takes two arguments")
            arr = eval_expression(tail[0], valuation)
            key = eval_expression(tail[1], valuation)
            # print(arr)
            # print(key)
            return arr[key]
        elif head == "store":
            if len(tail) != 3:
                raise ValueError("store takes three arguments")
            arr = eval_expression(tail[0], valuation)
            # NOTE:_VERY_IMPORTANT to dict this for a deep copy
            arr = dict(arr)
            key = eval_expression(tail[1], valuation)
            val = eval_expression(tail[2], valuation)
            arr[key] = val
            return arr
        elif head == "not":
            if len(tail) != 1:
                raise ValueError("not takes one argument")
            res = eval_expression(tail[0], valuation)
            return not res
        elif head == "or":
            if len(tail) != 2:
                raise ValueError("or takes two arguments")
            return (
                eval_expression(tail[0], valuation) 
                or eval_expression(tail[1], valuation))
        elif head == "and":
            if len(tail) != 2:
                raise ValueError("and takes two arguments")
            return (
                eval_expression(tail[0], valuation) 
                and eval_expression(tail[1], valuation))
        elif head =="=>":
            if len(tail) != 2:
                raise ValueError("=> takes two arguments")
            return (
                not eval_expression(tail[0], valuation) 
                or eval_expression(tail[1], valuation))
        elif head == "ite":
            if len(tail) != 3:
                raise ValueError("ite takes three arguments")
            cond = eval_expression(tail[0], valuation)
            if cond:
                return eval_expression(tail[1], valuation)
            else:
                return eval_expression(tail[2], valuation)
        elif head == "+":
            if len(tail) != 2:
                raise ValueError("+ takes two arguments")
            return (
                eval_expression(tail[0], valuation) 
                + eval_expression(tail[1], valuation))
        elif head == "*":
            if len(tail) != 2:
                raise ValueError("* takes two arguments")
            return (
                eval_expression(tail[0], valuation) 
                * eval_expression(tail[1], valuation))
        elif head == "tuple":
            return tuple(
                eval_expression(subexpr, valuation) 
                for subexpr in tail)
        elif head == "tuple.at":
            if len(tail) != 2:
                raise ValueError("tuple.at takes two arguments")
            tup = eval_expression(tail[0], valuation)
            idx = eval_expression(tail[1], valuation)
            if not isinstance(idx, int):
                raise ValueError("tuple.at index must be an integer. Got ", idx)
            if idx < 1 or idx > len(tup):
                raise ValueError(
                    f"Index {idx} out of bounds for tuple {tup}."
                    " Note: TLA+ is 1-indexed.")
            return tup[idx-1]
        elif head == "powerset":
            if len(tail) != 1:
                raise ValueError("powerset takes one argument")
            # pprint(expression)
            domain = eval_expression(tail[0], valuation)
            res =  powerset(domain)
            return res
        elif head == "comprehension":
            # pprint(expression)
            v = tail[0]
            domain = eval_expression(tail[1], valuation)
            body = tail[2]
            res = set()
            for x in domain:
                if v in valuation:
                    raise ValueError(f"Variable {v} already in valuation.")
                valuation[v] = x
                if eval_expression(body, valuation):
                    res.add(x)
                del valuation[v]
            res = frozenset(res)
            # pprint(res)
            # input("Press Enter to continue...")
            return res
        elif head == "exists":
            # pprint(expression)
            v = tail[0]
            domain = eval_expression(tail[1], valuation)
            body = tail[2]
            res = False
            for x in domain:
                if v in valuation:
                    raise ValueError(f"Variable {v} already in valuation.")
                valuation[v] = x
                if eval_expression(body, valuation):
                    res = True
                del valuation[v]
                if res:
                    break
            return res
        elif head == "forall":
            # pprint(expression)
            v = tail[0]
            # print("forall", v)
            domain = eval_expression(tail[1], valuation)
            body = tail[2]
            res = True
            for x in domain:
                if v in valuation:
                    raise ValueError(f"Variable {v} already in valuation.")
                valuation[v] = x
                if not eval_expression(body, valuation):
                    res = False
                del valuation[v]
                if not res:
                    break
            return res
        elif head == "operator":
            ophead = tail[0]
            optail = tail[1:]
            opargs = [eval_expression(x, valuation) for x in optail]
            return eval_operator_expression(ophead, opargs)
        else:
            raise ValueError(f"Unknown head: {head}")
    elif isinstance(expression, tuple):
        if len(expression) != 2:
            raise ValueError("Expected tuple of length 2")
        sort, val = expression
        if expression[1] is None:
            return None
        elif sort == "Bool":
            return val
        elif sort == "Int":
            return val
        elif sort[0] == "Set":
            if val == "emptyset":
                return set()
            else:
                raise ValueError(f"Unknown set: {val}")
        else:

            raise ValueError(f"Unknown sort for expression: {expression}")
    else:
        pprint(valuation)
        raise ValueError(
            f"Unknown expression with type {type(expression)}:" 
                f" {expression}")
