{"epoch": 0, "jobid": 0, "configindex": 3, "payload": "---- MODULE mldr_sm ----\n\\*\n\\* Logless protocol for managing configuration state for dynamic reconfiguration\n\\* in MongoDB replication.\n\\*\n\nEXTENDS Naturals, Integers, FiniteSets, Sequences, TLC\n\nCONSTANTS MaxTerm, MaxConfigVersion\nCONSTANTS Server\nCONSTANTS Secondary, Primary\n\nTerm == 0..MaxTerm\nVersion == 1..MaxConfigVersion\n\nVARIABLE currentTerm\nVARIABLE state\nVARIABLE configVersion\nVARIABLE configTerm\nVARIABLE config\n\nvars == <<currentTerm, state, configVersion, configTerm, config>>\n\n\\*\n\\* Helper operators.\n\\*\n\n\\* The set of all majority quorums of a given set.\nQuorums(S) == {i \\in SUBSET(S) : Cardinality(i) * 2 > Cardinality(S)}\n\n\\* Do all quorums of two sets intersect.\nQuorumsOverlap(x, y) == \\A qx \\in Quorums(x), qy \\in Quorums(y) : qx \\cap qy # {}\n\n\\* The min/max of a set of numbers.\nMin(s) == CHOOSE x \\in s : \\A y \\in s : x <= y\nMax(s) == CHOOSE x \\in s : \\A y \\in s : x >= y\n\n\\* Is a sequence empty.\nEmpty(s) == Len(s) = 0\n\n\\* Is the config of node i considered 'newer' than the config of node j. This is the condition for\n\\* node j to accept the config of node i.\nIsNewerConfig(i, j) ==\n    \\/ configTerm[i] > configTerm[j]\n    \\/ /\\ configTerm[i] = configTerm[j]\n       /\\ configVersion[i] > configVersion[j]\n\nIsNewerOrEqualConfig(i, j) ==\n    \\/ /\\ configTerm[i] = configTerm[j]\n       /\\ configVersion[i] = configVersion[j]\n    \\/ IsNewerConfig(i, j)\n\n\\* Compares two configs given as <<configVersion, configTerm>> tuples.\nNewerConfig(ci, cj) ==\n    \\* Compare configTerm first.\n    \\/ ci[2] > cj[2] \n    \\* Compare configVersion if terms are equal.\n    \\/ /\\ ci[2] = cj[2]\n       /\\ ci[1] > cj[1]  \n\n\\* Compares two configs given as <<configVersion, configTerm>> tuples.\nNewerOrEqualConfig(ci, cj) == NewerConfig(ci, cj) \\/ ci = cj\n\n\\* Can node 'i' currently cast a vote for node 'j' in term 'term'.\nCanVoteForConfig(i, j, term) ==\n    /\\ currentTerm[i] < term\n    /\\ IsNewerOrEqualConfig(j, i)\n    \n\\* A quorum of servers in the config of server i have i's config.\nConfigQuorumCheck(i) ==\n    \\E Q \\in Quorums(config[i]) : \\A t \\in Q : \n        /\\ configVersion[t] = configVersion[i]\n        /\\ configTerm[t] = configTerm[i]\n\n\\* A quorum of servers in the config of server i have the term of i.\nTermQuorumCheck(i) ==\n    \\E Q \\in Quorums(config[i]) : \\A t \\in Q : currentTerm[t] = currentTerm[i]    \n\nSymmDiff(X, Y) == (X \\ Y) \\cup (Y \\ X)\n\n-------------------------------------------------------------------------------------------\n\n\\*\n\\* Next state actions.\n\\*\n\n\\* Update terms if node 'i' has a newer term than node 'j' and ensure 'j' reverts to Secondary state.\nUpdateTermsExpr(i, j, newTerm) ==\n    /\\ currentTerm[i] > currentTerm[j]\n    /\\ newTerm = currentTerm[i]\n    /\\ currentTerm' = [currentTerm EXCEPT ![j] = newTerm]\n    /\\ state' = [state EXCEPT ![j] = Secondary]\n\nUpdateTerms(i, j, newTerm) == \n    /\\ UpdateTermsExpr(i, j, newTerm)\n    /\\ UNCHANGED <<configVersion, configTerm, config>>\n\nBecomeLeader(i, voteQuorum, newTerm) == \n    \\* Primaries make decisions based on their current configuration.\n    /\\ newTerm = currentTerm[i] + 1\n    /\\ voteQuorum \\in Quorums(config[i])\n    /\\ i \\in config[i]\n    /\\ i \\in voteQuorum\n    /\\ \\A v \\in voteQuorum : CanVoteForConfig(v, i, newTerm)\n    \\* Update the terms of each voter.\n    /\\ currentTerm' = [s \\in Server |-> IF s \\in voteQuorum THEN newTerm ELSE currentTerm[s]]\n    /\\ state' = [s \\in Server |->\n                    IF s = i THEN Primary\n                    ELSE IF s \\in voteQuorum THEN Secondary \\* All voters should revert to secondary state.\n                    ELSE state[s]]\n    \\* Update config's term on step-up.\n    /\\ configTerm' = [configTerm EXCEPT ![i] = newTerm]\n    /\\ UNCHANGED <<config, configVersion>>    \n\n\nReconfig(i, newConfig, newVersion) ==\n    /\\ state[i] = Primary \\* gt: state[i] = Primary\n    /\\ ConfigQuorumCheck(i) \\* gt: ConfigQuorumCheck(i)\n    /\\ TermQuorumCheck(i) \\* gt: TermQuorumCheck(i)\n    /\\ Cardinality(SymmDiff(config[i], newConfig)) <= 1 \\* gt: Cardinality(SymmDiff(config[i], newConfig)) <= 1\n    /\\ i \\in newConfig \\* gt: i \\in newConfig\n    /\\ newConfig # config[i] \\* gt: newConfig # config[i]\n    /\\ configTerm' = __Reconfig(i, newConfig, newVersion)_configTerm__ \\* gt: [configTerm EXCEPT ![i] = currentTerm[i]]\n    /\\ newVersion > configVersion[i] \\* gt: newVersion > configVersion[i]\n    /\\ configVersion' = [configVersion EXCEPT ![i] = newVersion] \\* gt: [configVersion EXCEPT ![i] = newVersion]\n    /\\ config' = [config EXCEPT ![i] = newConfig] \\* gt: [config EXCEPT ![i] = newConfig]\n    /\\ currentTerm' = currentTerm \\* gt: currentTerm\n    /\\ state' = state \\* gt: state\n\n\n\n\\* Node i sends its current config to node j.\nSendConfig(i, j, newTerm, newVersion) ==\n    /\\ state[j] = Secondary\n    /\\ IsNewerConfig(i, j)\n    /\\ newTerm = configTerm[i]\n    /\\ configTerm' = [configTerm EXCEPT ![j] = newTerm]\n    /\\ newVersion = configVersion[i]\n    /\\ configVersion' = [configVersion EXCEPT ![j] = newVersion]\n    /\\ config' = [config EXCEPT ![j] = config[i]]\n    /\\ UNCHANGED <<currentTerm, state>>\n\ntermination == \n    \\A s \\in Server : \n        /\\ configTerm[s] = MaxTerm\n        /\\ currentTerm[s] = MaxTerm\n        /\\ configVersion[s] = MaxConfigVersion\n\nTermination == \n    /\\ termination\n    /\\ UNCHANGED vars\n\nInit == \n    /\\ currentTerm = [i \\in Server |-> 0]\n    /\\ state       = [i \\in Server |-> Secondary]\n    /\\ configVersion =  [i \\in Server |-> 1]\n    /\\ configTerm    =  [i \\in Server |-> 0]\n    /\\ \\E initConfig \\in SUBSET Server :\n        /\\ initConfig # {}\n        /\\ config = [i \\in Server |-> initConfig]\n\nNext == \n    \\/ (\\E s \\in Server : \\E Q \\in SUBSET Server : \\E newTerm \\in Term :\n        BecomeLeader(s, Q, newTerm))\n    \\/ (\\E s,t \\in Server : \\E newTerm \\in Term : \n        UpdateTerms(s, t, newTerm))\n    \\/ (\\E s \\in Server, newConfig \\in SUBSET Server : \n        \\E newVersion \\in Version:\n        Reconfig(s, newConfig, newVersion))\n    \\/ (\\E s,t \\in Server :  \n        \\E newTerm \\in Term, newVersion \\in Version: \n        SendConfig(s, t, newTerm, newVersion))\n    \\/ Termination\n\nOnePrimaryPerTerm == \n    \\A s,t \\in Server :\n        (/\\ state[s] = Primary \n         /\\ state[t] = Primary\n         /\\ currentTerm[s] = currentTerm[t]) => (s = t)\n\n\n\\* <properties>\nSafety ==\n    /\\ OnePrimaryPerTerm\n    /\\ \\A s \\in Server : state[s] = Primary => configTerm[s] = currentTerm[s]\n\nTemporal == [][\n    \\A s \\in Server : \n        state[s] = Primary /\\ configVersion[s] # configVersion'[s] \n        => config[s] # config'[s]\n    ]_vars\n\nLiveness == \n    /\\ <> termination\n\\* </properties>\n\nSpec == \n    /\\ Init \n    /\\ [][Next]_vars\n    /\\ WF_vars(Next)\n\n\\* StateConstraint == \\A s \\in Server :\n                    \\* /\\ currentTerm[s] <= MaxTerm\n                    \\* /\\ configVersion[s] <= MaxConfigVersion\n\nServerSymmetry == Permutations(Server)\n\n============================================================================="}